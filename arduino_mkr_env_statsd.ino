#include "arduino_secrets.h"

/*

  Sends environmental data to a Splunk instance using the statsd protocol
  D. Dessy
  Dec 2019

*/

#undef NTP_SECTION

#include <WiFiNINA.h>
#include <WiFiUdp.h>
#include <Arduino_MKRENV.h>

#define MAC_LENGTH 6
#define STATSD_PORT_NUMBER 8125


float humidity;
float pressure;
float uvb;
float uvIndex;
float temperature;
float illuminance;
float uva;

// Approx. delta of temperature generated by the MKR board itself
const float DELTA_TEMP = 3.0;

int status = WL_IDLE_STATUS;
///////please enter your sensitive data in the Secret tab/arduino_secrets.h
char ssid[] = SECRET_SSID;        // your network SSID (name)
char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)
int keyIndex = 0;            // your network key Index number (needed only for WEP)
byte mac[ MAC_LENGTH ]; // Holds board MAC address
char board_id[ 2 * MAC_LENGTH + 1 ] = ""; // Holds the HEX representation of the MAC address

unsigned int localPort = 2390;      // local UDP port to listen on

// Splunk server details
char splunk_server[] = SECRET_SPLUNK_SERVER; // Splunk server FQDN
IPAddress splunk_ip;  // Will hold the current Splunk server IP address

#ifdef NTP_SECTION
// NTP time stamp is in the first 48 bytes of the message
#define NTP_PACKET_SIZE  48
byte packetBuffer[ NTP_PACKET_SIZE ]; //buffer to hold incoming and outgoing packets
const char timeServer[] = "be.pool.ntp.org";
#endif

WiFiUDP Udp; // statsd uses UDP, let's initialize it


void setup() {

  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Check if ENV board is present
  if (!ENV.begin()) {
    Serial.println("Failed to initialize MKR ENV shield!");
    // don't continue
    while (true);
  }

  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("Communication with WiFi module failed!");
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv < "1.0.0") {
    Serial.println("Please upgrade the firmware");
  }

  // attempt to connect to Wifi network:
  while (status != WL_CONNECTED) {
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:
    status = WiFi.begin(ssid, pass);
    // wait 10 seconds for connection:
    delay(10000);
  }

  // Gets board MAC address
  WiFi.macAddress(mac);
  array_to_string(mac, 6, board_id);
  Serial.print("Board ID: ");
  Serial.print(board_id);
  Serial.println(".");

  // start UDP
  Udp.begin(localPort);

}

void loop() {

  // read all the sensor values
  temperature = ENV.readTemperature(CELSIUS) - DELTA_TEMP;
  humidity    = ENV.readHumidity();
  pressure    = ENV.readPressure(MILLIBAR);
  illuminance = ENV.readIlluminance(LUX);
  uva         = ENV.readUVA();
  uvb         = ENV.readUVB();
  uvIndex     = ENV.readUVIndex();

  // Gets current Splunk server IP address
  int err = WiFi.hostByName(splunk_server, splunk_ip) ;
  if (err == 1) {
    // HostName has resolved, sends measures
    sendMeasure("temperature", temperature);
    sendMeasure("humidity", humidity);
    sendMeasure("pressure", pressure);
    sendMeasure("illuminance", illuminance);
    sendMeasure("uva", uva);
    sendMeasure("uvb", uvb);
    sendMeasure("uvIndex", uvIndex);
  }

  delay(60000);
}

// Format UDP message according to statsd protocol
void sendMeasure(char * m_name, float m_value) {


  Udp.beginPacket(splunk_ip, STATSD_PORT_NUMBER);
  Udp.print("sensor.");
  Udp.print(m_name);
  Udp.print(":");
  Udp.print(m_value);
  Udp.print("|g|#board_type:mkr1010,board_id:");
  Udp.print(board_id);
  Udp.print(",sensor_type:mkr_env");
  Udp.endPacket();

}

// Convert MAC address to its corresponding HEX string
void array_to_string(byte array[], unsigned int len, char buffer[])
{
  for (unsigned int i = 0; i < len; i++)
  {
    byte nib1 = (array[i] >> 4) & 0x0F;
    byte nib2 = (array[i] >> 0) & 0x0F;
    buffer[i * 2 + 0] = nib1  < 0xA ? '0' + nib1  : 'A' + nib1  - 0xA;
    buffer[i * 2 + 1] = nib2  < 0xA ? '0' + nib2  : 'A' + nib2  - 0xA;
  }
  buffer[len * 2] = '\0';
}
